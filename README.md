# Async Task Service (FastAPI + RabbitMQ + PostgreSQL)

Небольшой backend-сервис, который принимает задачи и обрабатывает их асинхронно через очередь.

## Быстрый старт

```bash
docker-compose up --build
```

После старта:
- API: `http://localhost:8000`
- RabbitMQ UI: `http://localhost:15672` (логин/пароль: `tasker`/`tasker`)

### Создать задачу

```bash
curl -X POST http://localhost:8000/tasks \
  -H "Content-Type: application/json" \
  -d '{"payload": "hello"}'
```

Ответ:
```json
{"task_id":"..."}
```

### Проверить статус

```bash
curl http://localhost:8000/tasks/<task_id>
```

### Healthcheck

```bash
curl http://localhost:8000/health
```

## Почему RabbitMQ, а не Kafka

Я выбрал RabbitMQ, потому что здесь это классическая очередь задач, а не стриминг событий.
Kafka мощнее, но тяжелее в настройке и эксплуатации, и ради одной простой очереди это
избыточно. RabbitMQ закрывает требования "забрал задачу -> обработал -> подтвердил" и
понятно масштабируется добавлением воркеров.

Если бы задача была про потоковую обработку/аналитику или нужен был очень высокий throughput
с жесткими SLA на порядок, тогда да - Kafka.

## Масштабирование

- Основной рычаг - количество `worker`-реплик (это сразу увеличивает скорость обработки).
- `backend` масштабируется отдельно, если растёт входящий трафик на `POST /tasks`.
- БД лучше вынести в управляемый PostgreSQL/кластер и настроить пул подключений.
- При росте сложности - разные очереди по типам задач и отдельные воркеры под них.

## Потенциальные точки отказа

- RabbitMQ в одном экземпляре - единая точка отказа, при недоступности брокера очередь простаивает.
- PostgreSQL в одном экземпляре - при падении БД ломается и API, и воркеры.
- Сейчас нет ретраев/идемпотентности: если воркер упал в середине, задача может завершиться с `failed`.
- Нет защиты от «долгих» задач (таймаутов), это тоже может подвесить обработку.

## Что бы улучшил для продакшена

- Ретраи с backoff, DLQ и метрики очереди (в т.ч. длина/latency).
- Идемпотентные задачи (например, ключ на payload), чтобы не бояться повторной доставки.
- Healthcheck/readycheck и алерты по брокеру/БД/воркерам.
- Миграции БД через Alembic вместо автосоздания таблиц на старте.
- Централизованные логи + трассировка (OpenTelemetry/ELK) для дебага.
- Таймауты, лимиты по времени и более аккуратная обработка исключений.

## Архитектура

- `POST /tasks` сохраняет запись в PostgreSQL со статусом `pending` и отправляет задачу в очередь.
- Celery-воркер забирает задачу, ставит `processing`, имитирует работу (sleep 2-5 сек),
  затем пишет результат и переводит в `done` (или `failed`, если поймал ошибку).
